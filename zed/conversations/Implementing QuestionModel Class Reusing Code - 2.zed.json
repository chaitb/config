{"id":"e1b3d641-0ec3-4d39-9319-9786901bb10f","zed":"context","version":"0.4.0","text":"\n\n```ts 1p-quiz/app/model/QuestionModel.ts\nimport { z } from \"zod\";\nimport { FullQuestionEdit } from \"~/client/components/QuestionMain\";\nimport { DBQuestion, QuestionInsert } from \"~/db.server/schema/question\";\n\n// Zod schema for QuestionType\nconst questionTypeSchema = z.enum([\n  \"text\",\n  \"single-select\",\n  \"multi-select\",\n  \"text-area\",\n]);\n\nexport const questionCategorySchema = z.enum([\n  \"basic_info\",\n  \"routine\",\n  \"personality\",\n  \"relationships\",\n  \"religion\",\n  \"work\",\n  \"politics\",\n  \"hobbies\",\n  \"family\",\n]);\n\nconst optionTagSchema = z\n  .array(z.tuple([z.string(), z.enum([\"high\", \"medium\", \"low\"])]))\n  .optional();\n\n// Zod schema for Option\nconst optionSchema = z.object({\n  label: z.string(),\n  value: z.string(),\n  tags: optionTagSchema,\n  reason: z.string().optional(),\n  next: z.array(z.object({ id: z.number(), chance: z.number() })).optional(),\n});\n\n// Zod schema for question content\nexport const baseContentSchema = z.object({\n  text: z.string(),\n  type: questionTypeSchema,\n  options: z.array(optionSchema).optional(),\n});\n\nconst questionContentSchema = baseContentSchema.extend({\n  next: z.array(z.object({ id: z.number(), chance: z.number() })).optional(),\n});\n\n// Zod schema for PartialQuestion\nexport const partialQuestionSchema = z.object({\n  id: z.union([z.number(), z.literal(\"auto\")]).optional(),\n  content: questionContentSchema,\n  category: questionCategorySchema,\n  archetypeTags: z.array(z.string()).optional(),\n  weight: z.number().optional(),\n  difficulty: z.number().optional(),\n  vector: z.array(z.number()).optional(),\n});\n\n// Type inference from the schema\nexport type PartialQuestion = z.infer<typeof partialQuestionSchema>;\n\n// Types for question and options\nexport type Option = z.infer<typeof optionSchema>;\nexport type QuestionType = z.infer<typeof questionTypeSchema>;\nexport type QuestionCategory = z.infer<typeof questionCategorySchema>;\nexport type QuestionContent = z.infer<typeof questionContentSchema>;\nexport type QuestionShortText = `${QuestionType}/${string}/${string}`;\n\n// same as DBQuestion\nexport interface FullQuestion extends PartialQuestion {\n  id: number;\n  text: QuestionShortText;\n  content: QuestionContent;\n  createdAt?: Date;\n}\n\nexport function toFullQuestion(\n  id: number,\n  questionContent: PartialQuestion\n): FullQuestion {\n  return {\n    id: Number(id),\n    ...fullQuestionFields(questionContent),\n  };\n}\n\nexport function fullQuestionFields(\n  questionContent: PartialQuestion\n): Omit<FullQuestion, \"id\"> {\n  return {\n    text: `${questionContent.content.type}/${questionContent.content.text}/${questionContent.category}`,\n    createdAt: new Date(),\n    ...questionContent,\n  };\n}\n\nexport function isFullQuestion(\n  question: FullQuestion | FullQuestionEdit\n): question is FullQuestion {\n  return question.id !== undefined && question.id !== \"auto\";\n}\n```\n\n```ts 1p-quiz/app/db.server/queries/questionQueries.ts\nimport { eq } from \"drizzle-orm\";\nimport {\n  DBQuestion,\n  QuestionInsert,\n  questionTable,\n  responseTable,\n} from \"~/db.server/schema/question\";\nimport {\n  AppError,\n  ApiResult,\n  error,\n  newError,\n  success,\n} from \"~/model/ApiResult\";\nimport type { FullQuestion } from \"~/model/QuestionModelModel\";\nimport { MyDB } from \"../db\";\n\n// Placeholder function to simulate fetching question from the server\nexport async function getQuestionById(\n  db: MyDB,\n  questionId: number,\n  _sessionId?: string\n): Promise<FullQuestion | null> {\n  const dbQuestion = await db\n    .select()\n    .from(questionTable)\n    .where(eq(questionTable.id, questionId));\n  if (dbQuestion.length === 0) {\n    return null;\n  } else {\n    return dbQuestion[0] as FullQuestion;\n  }\n}\n\nexport async function updateQuestion(\n  db: MyDB,\n  question: Partial<QuestionInsert> & {\n    id: FullQuestion[\"id\"];\n  }\n) {\n  const result = await db\n    .update(questionTable)\n    .set(question)\n    .where(eq(questionTable.id, question.id));\n  if (result.rowsAffected === 0) {\n    return error({\n      code: \"FAILED_TO_UPDATE_QUESTION\",\n      message: \"Failed to update question\",\n    });\n  }\n  return success({ id: question.id });\n}\n\nexport async function saveQuestion(\n  db: MyDB,\n  question: QuestionInsert\n): Promise<ApiResult<{ id: DBQuestion[\"id\"] }, AppError>> {\n  try {\n    if (question.id !== undefined && typeof question.id === \"number\") {\n      return updateQuestion(db, question);\n    } else {\n      const result = await db.insert(questionTable).values(question).returning({\n        id: questionTable.id,\n      });\n      if (result.length === 0) {\n        return error({\n          code: \"FAILED_TO_SAVE_QUESTION\",\n          message: \"Failed to save question\",\n        });\n      }\n      return success(result[0]);\n    }\n  } catch (e) {\n    console.error(e);\n    return newError(\"FAILED_TO_SAVE_QUESTION\", \"Failed to save question\", e);\n  }\n}\n\nexport async function getQnAHistory(db: MyDB, sessionId: string) {\n  const responses = await db\n    .select()\n    .from(responseTable)\n    .where(eq(responseTable.sessionId, sessionId))\n    .leftJoin(questionTable, eq(responseTable.questionId, questionTable.id))\n    .orderBy(questionTable.id);\n\n  return responses;\n}\n\nexport async function getAllQuestions(db: MyDB) {\n  const questions = (await db.select().from(questionTable)) as FullQuestion[];\n  return questions;\n}\n\nexport async function deleteQuestion(\n  db: MyDB,\n  questionId: number\n): Promise<ApiResult<{ id: number }, AppError>> {\n  const result = await db\n    .delete(questionTable)\n    .where(eq(questionTable.id, questionId));\n\n  if (result.rowsAffected === 0) {\n    return error({\n      code: \"FAILED_TO_DELETE_QUESTION\",\n      message: \"Failed to delete question\",\n    });\n  }\n  return success({ id: questionId });\n}\n```\n\n```ts 1p-quiz/app/db.server/queries/vectorize.ts\nimport { updateQuestion } from \"./questionQueries\";\nimport { MyDB } from \"../db\";\nimport { QuestionInsert } from \"../schema/question\";\nimport { OpenAI } from \"openai\";\n\nasync function vectorize(\n  question: string,\n  openai: OpenAI\n): Promise<number[] | null> {\n  const embeddingResponse = await openai.embeddings.create({\n    model: \"text-embedding-ada-002\",\n    input: question,\n  });\n\n  const res = embeddingResponse.data;\n  console.log(res);\n  if (res.length) {\n    return res[0].embedding;\n  }\n  return null;\n}\n\nasync function vectorizeAndSaveQuestion(\n  db: MyDB,\n  question: QuestionInsert,\n  openai: OpenAI\n) {\n  const input = `Question: ${\n    question.content.text\n  } \\nOptions: [${question.content.options\n    ?.map((o) => o.label)\n    .join(\", \")}] \\nCategory: ${question.category}`;\n\n  if (question.id) {\n    const vector = await vectorize(input, openai);\n    const saveResponse = updateQuestion(db, { id: question.id, vector });\n    return saveResponse;\n  }\n}\n\nexport { vectorize, vectorizeAndSaveQuestion };\n```\n\n\n\nimplement the class QuestionModel re-using code from other places mentioned\n\nCertainly! Below is the implementation of the `QuestionModel` class, reusing code from the provided snippets. The `QuestionModel` class encapsulates operations related to questions, utilizing the existing functions and types for database interactions and vectorization.\n\n```ts\n// app/model/QuestionModel.ts\n\nimport { z } from \"zod\";\nimport { MyDB } from \"~/db.server/db\";\nimport { OpenAI } from \"openai\";\nimport {\n  getQuestionById as dbGetQuestionById,\n  saveQuestion as dbSaveQuestion,\n  updateQuestion as dbUpdateQuestion,\n  deleteQuestion as dbDeleteQuestion,\n  getAllQuestions as dbGetAllQuestions,\n} from \"~/db.server/queries/questionQueries\";\nimport { vectorizeAndSaveQuestion } from \"~/db.server/queries/vectorize\";\nimport {\n  partialQuestionSchema,\n  PartialQuestion,\n  QuestionContent,\n  Option,\n  QuestionType,\n  QuestionCategory,\n  FullQuestion,\n  isFullQuestion,\n  toFullQuestion,\n  fullQuestionFields,\n} from \"~/model/QuestionModel\";\nimport { QuestionInsert } from \"~/db.server/schema/question\";\nimport {\n  ApiResult,\n  AppError,\n  success,\n  error,\n  newError,\n} from \"~/model/ApiResult\";\n\nexport class QuestionModel {\n  constructor(private db: MyDB, private openai?: OpenAI) {}\n\n  /**\n   * Fetches a question by its ID.\n   * @param questionId The ID of the question to retrieve.\n   * @param sessionId The session ID, if applicable.\n   * @returns The full question or null if not found.\n   */\n  async getQuestionById(\n    questionId: number,\n    sessionId?: string\n  ): Promise<FullQuestion | null> {\n    return dbGetQuestionById(this.db, questionId, sessionId);\n  }\n\n  /**\n   * Saves a new question to the database.\n   * @param question The question data to save.\n   * @returns The result containing the new question ID or an error.\n   */\n  async saveQuestion(\n    question: QuestionInsert\n  ): Promise<ApiResult<{ id: number }, AppError>> {\n    return dbSaveQuestion(this.db, question);\n  }\n\n  /**\n   * Updates an existing question in the database.\n   * @param question The question data to update, including its ID.\n   * @returns The result containing the updated question ID or an error.\n   */\n  async updateQuestion(\n    question: Partial<QuestionInsert> & { id: number }\n  ): Promise<ApiResult<{ id: number }, AppError>> {\n    return dbUpdateQuestion(this.db, question);\n  }\n\n  /**\n   * Deletes a question from the database.\n   * @param questionId The ID of the question to delete.\n   * @returns The result containing the deleted question ID or an error.\n   */\n  async deleteQuestion(\n    questionId: number\n  ): Promise<ApiResult<{ id: number }, AppError>> {\n    return dbDeleteQuestion(this.db, questionId);\n  }\n\n  /**\n   * Retrieves all questions from the database.\n   * @returns An array of all full questions.\n   */\n  async getAllQuestions(): Promise<FullQuestion[]> {\n    return dbGetAllQuestions(this.db);\n  }\n\n  /**\n   * Vectorizes and saves a question using OpenAI embeddings.\n   * @param question The question data to vectorize and save.\n   * @returns The result containing the question ID or an error.\n   */\n  async vectorizeAndSaveQuestion(\n    question: QuestionInsert\n  ): Promise<ApiResult<{ id: number }, AppError>> {\n    if (!this.openai) {\n      return error({\n        code: \"OPENAI_CLIENT_NOT_INITIALIZED\",\n        message: \"OpenAI client is not initialized\",\n      });\n    }\n\n    try {\n      return await vectorizeAndSaveQuestion(this.db, question, this.openai);\n    } catch (e) {\n      console.error(e);\n      return newError(\n        \"FAILED_TO_VECTORIZE_AND_SAVE_QUESTION\",\n        \"Failed to vectorize and save question\",\n        e\n      );\n    }\n  }\n\n  /**\n   * Validates a partial question using the Zod schema.\n   * @param question The partial question to validate.\n   * @returns The validated question or throws a ZodError.\n   */\n  validatePartialQuestion(question: unknown): PartialQuestion {\n    return partialQuestionSchema.parse(question);\n  }\n\n  /**\n   * Converts a partial question to a full question.\n   * @param id The ID to assign to the question.\n   * @param questionContent The partial question content.\n   * @returns The full question.\n   */\n  toFullQuestion(id: number, questionContent: PartialQuestion): FullQuestion {\n    return toFullQuestion(id, questionContent);\n  }\n\n  /**\n   * Checks if a question is a full question.\n   * @param question The question to check.\n   * @returns True if it is a full question, false otherwise.\n   */\n  isFullQuestion(question: FullQuestion | PartialQuestion): question is FullQuestion {\n    return isFullQuestion(question);\n  }\n}\n```\n\n**Explanation:**\n\n- **Class Structure:** The `QuestionModel` class is designed to encapsulate all the operations related to questions, including database interactions and vectorization.\n\n- **Constructor:** The constructor accepts a `MyDB` instance for database operations and an optional `OpenAI` instance for vectorization.\n\n- **Methods:**\n  - **getQuestionById:** Fetches a question by ID using the existing `dbGetQuestionById` function.\n  - **saveQuestion:** Saves a new question using the existing `dbSaveQuestion` function.\n  - **updateQuestion:** Updates an existing question using the existing `dbUpdateQuestion` function.\n  - **deleteQuestion:** Deletes a question using the existing `dbDeleteQuestion` function.\n  - **getAllQuestions:** Retrieves all questions using the existing `dbGetAllQuestions` function.\n  - **vectorizeAndSaveQuestion:** Vectorizes a question using OpenAI embeddings and saves it using the existing `vectorizeAndSaveQuestion` function.\n  - **validatePartialQuestion:** Validates a partial question against the Zod schema.\n  - **toFullQuestion:** Converts a partial question to a full question using the existing `toFullQuestion` function.\n  - **isFullQuestion:** Determines if a question is a full question using the existing `isFullQuestion` function.\n\n- **Error Handling:** The methods utilize the existing `ApiResult`, `AppError`, `success`, `error`, and `newError` types and functions for consistent error handling.\n\n- **Reused Code:** The class imports and uses existing types, functions, and schemas from the provided code snippets, ensuring consistency and reusability.\n\n**Note:** Ensure that the paths in the import statements are correctly resolved based on your project structure.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":69}}},{"id":{"replica_id":0,"value":57},"start":6853,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":70}}},{"id":{"replica_id":0,"value":58},"start":13110,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":71}}}],"summary":"Implementing QuestionModel Class Reusing Code","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":2,"end":2835},"icon":"File","label":"1p-quiz/app/model/QuestionModel.ts","metadata":{"path":"1p-quiz/app/model/QuestionModel.ts"}},{"range":{"start":2836,"end":5695},"icon":"File","label":"1p-quiz/app/db.server/queries/questionQueries.ts","metadata":{"path":"1p-quiz/app/db.server/queries/questionQueries.ts"}},{"range":{"start":5696,"end":6773},"icon":"File","label":"1p-quiz/app/db.server/queries/vectorize.ts","metadata":{"path":"1p-quiz/app/db.server/queries/vectorize.ts"}}]}