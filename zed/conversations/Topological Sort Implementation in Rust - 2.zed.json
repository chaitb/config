{"id":"f79e1a05-f131-4885-9a8b-59b3e1ec548d","zed":"context","version":"0.4.0","text":"```rs aoc24/src/bin/5.rs\n// Imports\nuse std::collections::HashMap;\nuse std::io;\nuse std::io::prelude::*;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\nstruct Rule {\n    left: i32,\n    right: i32,\n}\n\nfn main() {\n    println!(\"Aoc 2024 - Day 5\");\n    println!(\"{:?}\", process());\n}\n\npub fn read_lines() -> Vec<String> {\n    let stdin = io::stdin();\n    let stdin_lock = stdin.lock();\n    let vec = stdin_lock.lines().filter_map(|l| l.ok()).collect();\n\n    vec\n}\n\nfn process() -> (i32, i32) {\n    let mut res = 0;\n    let mut fixed_res = 0;\n    let mut ordering_rules: Vec<Rule> = Vec::new();\n    for line in read_lines() {\n        if line.is_empty() {\n            continue;\n        }\n        if line.contains(\"|\") {\n            let parts: Vec<&str> = line.split(\"|\").collect();\n            let left = parts[0].parse::<i32>().unwrap();\n            let right = parts[1].parse::<i32>().unwrap();\n            ordering_rules.push(Rule { left, right });\n        } else {\n            let nums: Vec<i32> = line.split(',').map(|x| x.parse::<i32>().unwrap()).collect();\n            let (line_res, fixed) = check_update(&nums, &ordering_rules);\n            if line_res {\n                let middle_element = nums[nums.len() / 2 as usize];\n                res += middle_element;\n            } else {\n                let middle_element = fixed[fixed.len() / 2 as usize];\n                fixed_res += middle_element;\n            }\n        }\n    }\n\n    (res, fixed_res)\n}\n\nfn check_update(nums: &Vec<i32>, ordering_rules: &Vec<Rule>) -> (bool, Vec<i32>) {\n    let mut correct = true;\n    let mut rule_eval_pairs: HashMap<&Rule, [Option<usize>; 2]> = HashMap::new();\n    for i in 0..nums.len() {\n        for rule in ordering_rules {\n            if nums[i] == rule.left {\n                match rule_eval_pairs.get(rule) {\n                    Some(&val) => {\n                        rule_eval_pairs.insert(rule, [Some(i), val[1]]);\n                    }\n                    None => {\n                        rule_eval_pairs.insert(rule, [Some(i), None]);\n                    }\n                }\n            }\n            if nums[i] == rule.right {\n                match rule_eval_pairs.get(rule) {\n                    Some(&val) => {\n                        rule_eval_pairs.insert(rule, [val[0], Some(i)]);\n                    }\n                    None => {\n                        rule_eval_pairs.insert(rule, [None, Some(i)]);\n                    }\n                }\n            }\n        }\n    }\n\n    let mut fixed = nums.clone();\n\n    println!(\"{:?}\", nums);\n\n    // implement a topological sort\n    // such that the left element is always before the right element\n    // based on the ordering rules\n\n    (correct, fixed)\n}\n```\n\nimplement the topological sort based on the description\nTo implement the topological sort based on the description, we need to ensure that for each rule, the `left` element appears before the `right` element in the list. We can achieve this by using Kahn's algorithm for topological sorting. Here's how you can implement it:\n\n1. **Build the graph**: Represent the rules as a directed graph where each rule `left -> right` is an edge from `left` to `right`.\n2. **Calculate in-degrees**: Count the number of incoming edges for each node.\n3. **Initialize the queue**: Add all nodes with zero in-degrees to the queue.\n4. **Process the queue**: Remove nodes from the queue, add them to the sorted list, and decrease the in-degrees of their neighbors. If a neighbor's in-degree becomes zero, add it to the queue.\n5. **Check for cycles**: If the sorted list does not contain all nodes, there is a cycle in the graph.\n\nHere's the updated code with the topological sort implemented:\n\n```rs\nuse std::collections::{HashMap, HashSet, VecDeque};\nuse std::io;\nuse std::io::prelude::*;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\nstruct Rule {\n    left: i32,\n    right: i32,\n}\n\nfn main() {\n    println!(\"Aoc 2024 - Day 5\");\n    println!(\"{:?}\", process());\n}\n\npub fn read_lines() -> Vec<String> {\n    let stdin = io::stdin();\n    let stdin_lock = stdin.lock();\n    let vec = stdin_lock.lines().filter_map(|l| l.ok()).collect();\n\n    vec\n}\n\nfn process() -> (i32, i32) {\n    let mut res = 0;\n    let mut fixed_res = 0;\n    let mut ordering_rules: Vec<Rule> = Vec::new();\n    for line in read_lines() {\n        if line.is_empty() {\n            continue;\n        }\n        if line.contains(\"|\") {\n            let parts: Vec<&str> = line.split(\"|\").collect();\n            let left = parts[0].parse::<i32>().unwrap();\n            let right = parts[1].parse::<i32>().unwrap();\n            ordering_rules.push(Rule { left, right });\n        } else {\n            let nums: Vec<i32> = line.split(',').map(|x| x.parse::<i32>().unwrap()).collect();\n            let (line_res, fixed) = check_update(&nums, &ordering_rules);\n            if line_res {\n                let middle_element = nums[nums.len() / 2 as usize];\n                res += middle_element;\n            } else {\n                let middle_element = fixed[fixed.len() / 2 as usize];\n                fixed_res += middle_element;\n            }\n        }\n    }\n\n    (res, fixed_res)\n}\n\nfn check_update(nums: &Vec<i32>, ordering_rules: &Vec<Rule>) -> (bool, Vec<i32>) {\n    let mut correct = true;\n    let mut rule_eval_pairs: HashMap<&Rule, [Option<usize>; 2]> = HashMap::new();\n    for i in 0..nums.len() {\n        for rule in ordering_rules {\n            if nums[i] == rule.left {\n                match rule_eval_pairs.get(rule) {\n                    Some(&val) => {\n                        rule_eval_pairs.insert(rule, [Some(i), val[1]]);\n                    }\n                    None => {\n                        rule_eval_pairs.insert(rule, [Some(i), None]);\n                    }\n                }\n            }\n            if nums[i] == rule.right {\n                match rule_eval_pairs.get(rule) {\n                    Some(&val) => {\n                        rule_eval_pairs.insert(rule, [val[0], Some(i)]);\n                    }\n                    None => {\n                        rule_eval_pairs.insert(rule, [None, Some(i)]);\n                    }\n                }\n            }\n        }\n    }\n\n    let mut fixed = nums.clone();\n\n    println!(\"{:?}\", nums);\n\n    // Build the graph\n    let mut graph: HashMap<i32, Vec<i32>> = HashMap::new();\n    let mut in_degree: HashMap<i32, usize> = HashMap::new();\n    let mut nodes: HashSet<i32> = HashSet::new();\n\n    for rule in ordering_rules {\n        graph.entry(rule.left).or_default().push(rule.right);\n        *in_degree.entry(rule.right).or_default() += 1;\n        in_degree.entry(rule.left).or_default();\n        nodes.insert(rule.left);\n        nodes.insert(rule.right);\n    }\n\n    // Initialize the queue with nodes having zero in-degree\n    let mut queue: VecDeque<i32> = VecDeque::new();\n    for &node in &nodes {\n        if *in_degree.get(&node).unwrap_or(&0) == 0 {\n            queue.push_back(node);\n        }\n    }\n\n    // Perform topological sort\n    let mut sorted: Vec<i32> = Vec::new();\n    while let Some(node) = queue.pop_front() {\n        sorted.push(node);\n        if let Some(neighbors) = graph.get(&node) {\n            for &neighbor in neighbors {\n                let in_deg = in_degree.get_mut(&neighbor).unwrap();\n                *in_deg -= 1;\n                if *in_deg == 0 {\n                    queue.push_back(neighbor);\n                }\n            }\n        }\n    }\n\n    // Check if topological sort is possible (i.e., no cycles)\n    if sorted.len() != nodes.len() {\n        correct = false;\n    } else {\n        // Reorder the nums array based on the topological sort\n        let mut index_map: HashMap<i32, usize> = HashMap::new();\n        for (i, &num) in nums.iter().enumerate() {\n            index_map.insert(num, i);\n        }\n        sorted.sort_by_key(|&num| index_map.get(&num).unwrap());\n        fixed = sorted;\n    }\n\n    (correct, fixed)\n}\n```\n\nThis code implements the topological sort using Kahn's algorithm and ensures that the `left` element appears before the `right` element in the list based on the given rules. If a cycle is detected, it sets `correct` to `false`. The `fixed` list is updated to reflect the sorted order if no cycle is found.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":348}}},{"id":{"replica_id":0,"value":30},"start":2776,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":349}}},{"id":{"replica_id":0,"value":31},"start":8217,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":350}}}],"summary":"Topological Sort Implementation in Rust","slash_command_output_sections":[{"range":{"start":0,"end":2719},"icon":"File","label":"aoc24/src/bin/5.rs","metadata":{"path":"aoc24/src/bin/5.rs"}}]}